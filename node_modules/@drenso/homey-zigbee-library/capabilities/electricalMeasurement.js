"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const zigbee_clusters_1 = require("zigbee-clusters");
const deviceFactor_1 = __importStar(require("../lib/helper/deviceFactor"));
const ExtendedElectricalMeasurementCluster_1 = require("../lib/clusters/ExtendedElectricalMeasurementCluster");
const attributeDevice_1 = require("../lib/attributeDevice");
async function initElectricalMeasurementDevice(device, zclNode, { endpointId, useInstantaneousDemand, noPowerFactorReporting, minVoltageMeasurementChange, minCurrentMeasurementChange, minPowerMeasurementChange, minMeasurementInterval, maxMeasurementInterval, sumAverageUpdateInterval, additionalVoltageMultiplier, additionalCurrentMultiplier, additionalPowerMultiplier, } = {}) {
    device.log('Determining measurement type');
    const measurementType = await zclNode
        .endpoints[endpointId ?? device.getClusterEndpoint(ExtendedElectricalMeasurementCluster_1.ExtendedElectricalMeasurementCluster) ?? 1]
        ?.clusters[ExtendedElectricalMeasurementCluster_1.ExtendedElectricalMeasurementCluster.NAME]
        ?.readAttributes(['measurementType'])
        ?.catch(e => device.error('Failed to read', 'measurementType', 'from', ExtendedElectricalMeasurementCluster_1.ExtendedElectricalMeasurementCluster.NAME, e));
    device.log('Measurement type is', measurementType ?? 'not provided by device');
    const measurementFlags = measurementType?.measurementType?.getBits();
    // Configure phase A if there are no measurement types, if it is explicitly reported or if no phase is reported at all
    const hasPhaseA = !measurementFlags || measurementFlags.includes('phaseAMeasurement') || (!measurementFlags.includes('phaseAMeasurement') && !measurementFlags.includes('phaseBMeasurement') && !measurementFlags.includes('phaseCMeasurement'));
    const updateAverageCapabilityFactory = (averageCapability) => {
        return () => {
            if (!device.hasCapability(averageCapability)) {
                return;
            }
            const capabilities = [averageCapability + '.phase_a', averageCapability + '.phase_b', averageCapability + '.phase_c'];
            const values = [];
            for (const capability of capabilities) {
                values.push(device.hasCapability(capability) ? device.getCapabilityValue(capability) : 0);
            }
            const count = values.filter(n => n > 0).length;
            device.setCapabilityValue(averageCapability, count !== 0
                ? values.reduce((value, sum) => value + sum, 0) / count
                : 0).catch(device.error);
        };
    };
    const updateSummationCapabilityFactory = (summationCapability) => {
        return () => {
            if (!device.hasCapability(summationCapability)) {
                return;
            }
            const capabilities = [summationCapability + '.phase_a', summationCapability + '.phase_b', summationCapability + '.phase_c'];
            const values = [];
            for (const capability of capabilities) {
                values.push(device.hasCapability(capability) ? device.getCapabilityValue(capability) : 0);
            }
            device.setCapabilityValue(summationCapability, values.reduce((value, sum) => value + sum, 0)).catch(device.error);
        };
    };
    if (hasPhaseA) {
        if (device.hasCapability('measure_voltage.phase_a')) {
            device.log('Initialising measure_voltage.phase_a capability with measure_voltage average if it exists');
            await (0, deviceFactor_1.default)(device, zclNode, 'measure_voltage.phase_a', ExtendedElectricalMeasurementCluster_1.ExtendedElectricalMeasurementCluster, 'acVoltageFactor', endpointId, noPowerFactorReporting, {
                minMeasurementInterval,
                maxMeasurementInterval,
                minMeasurementChange: minVoltageMeasurementChange,
            }, updateAverageCapabilityFactory('measure_voltage'), sumAverageUpdateInterval, additionalVoltageMultiplier)
                .then(() => device.log('Initialised measure_voltage.phase_a capability'))
                .catch(e => device.error('Failed to initialise measure_voltage.phase_a capability', e));
        }
        else if (device.hasCapability('measure_voltage')) {
            device.log('Initialising measure_voltage capability');
            await (0, deviceFactor_1.default)(device, zclNode, 'measure_voltage', ExtendedElectricalMeasurementCluster_1.ExtendedElectricalMeasurementCluster, 'acVoltageFactor', endpointId, noPowerFactorReporting, {
                minMeasurementInterval,
                maxMeasurementInterval,
                minMeasurementChange: minVoltageMeasurementChange,
            }, undefined, undefined, additionalVoltageMultiplier)
                .then(() => device.log('Initialised measure_voltage capability'))
                .catch(e => device.error('Failed to initialise measure_voltage capability', e));
        }
        if (device.hasCapability('measure_current.phase_a')) {
            device.log('Initialising measure_current.phase_a capability with summation if it exists');
            await (0, deviceFactor_1.default)(device, zclNode, 'measure_current.phase_a', ExtendedElectricalMeasurementCluster_1.ExtendedElectricalMeasurementCluster, 'acCurrentFactor', endpointId, noPowerFactorReporting, {
                minMeasurementInterval,
                maxMeasurementInterval,
                minMeasurementChange: minCurrentMeasurementChange,
            }, updateSummationCapabilityFactory('measure_current'), sumAverageUpdateInterval, additionalCurrentMultiplier)
                .then(() => device.log('Initialised measure_current.phase_a capability'))
                .catch(e => device.error('Failed to initialise measure_current.phase_a capability', e));
        }
        else if (device.hasCapability('measure_current')) {
            device.log('Initialising measure_current capability');
            await (0, deviceFactor_1.default)(device, zclNode, 'measure_current', ExtendedElectricalMeasurementCluster_1.ExtendedElectricalMeasurementCluster, 'acCurrentFactor', endpointId, noPowerFactorReporting, {
                minMeasurementInterval,
                maxMeasurementInterval,
                minMeasurementChange: minCurrentMeasurementChange,
            }, undefined, undefined, additionalCurrentMultiplier)
                .then(() => device.log('Initialised measure_current capability'))
                .catch(e => device.error('Failed to initialise measure_current capability', e));
        }
        if (device.hasCapability('measure_power.phase_a')) {
            device.log('Initialising measure_power.phase_a capability with summation if it exists');
            await (0, deviceFactor_1.default)(device, zclNode, 'measure_power.phase_a', useInstantaneousDemand ? zigbee_clusters_1.CLUSTER.METERING : ExtendedElectricalMeasurementCluster_1.ExtendedElectricalMeasurementCluster, useInstantaneousDemand ? 'instantaneousDemandFactor' : 'activePowerFactor', endpointId, noPowerFactorReporting, {
                minMeasurementInterval,
                maxMeasurementInterval,
                minMeasurementChange: minPowerMeasurementChange,
            }, updateSummationCapabilityFactory('measure_power'), sumAverageUpdateInterval, 
            // Fall back to 1000 additional multiplier as the cluster definition for instantaneous demand defines kW as unit of measurement
            additionalPowerMultiplier ?? (useInstantaneousDemand ? 1000 : undefined))
                .then(() => device.log('Initialised measure_power.phase_a capability'))
                .catch(e => device.error('Failed to initialise measure_power.phase_a capability', e));
        }
        else if (device.hasCapability('measure_power')) {
            device.log('Initialising measure_power capability');
            await (0, deviceFactor_1.default)(device, zclNode, 'measure_power', useInstantaneousDemand ? zigbee_clusters_1.CLUSTER.METERING : ExtendedElectricalMeasurementCluster_1.ExtendedElectricalMeasurementCluster, useInstantaneousDemand ? 'instantaneousDemandFactor' : 'activePowerFactor', endpointId, noPowerFactorReporting, {
                minMeasurementInterval,
                maxMeasurementInterval,
                minMeasurementChange: minPowerMeasurementChange,
            }, undefined, undefined, 
            // Fall back to 1000 additional multiplier as the cluster definition for instantaneous demand defines kW as unit of measurement
            additionalPowerMultiplier ?? (useInstantaneousDemand ? 1000 : undefined))
                .then(() => device.log('Initialised measure_power capability'))
                .catch(e => device.error('Failed to initialise measure_power capability', e));
        }
    }
    if (measurementFlags && measurementFlags.includes('phaseBMeasurement')) {
        device.log('Initialising Phase B measurements');
        if (device.hasCapability('measure_voltage.phase_b')) {
            device.log('Initialising measure_voltage.phase_b capability');
            await (0, attributeDevice_1.initReadOnlyCapability)(device, zclNode, 'measure_voltage.phase_b', ExtendedElectricalMeasurementCluster_1.ExtendedElectricalMeasurementCluster, 'rmsVoltagePhB', (0, deviceFactor_1.factorReportParserBuilder)(() => device['acVoltageFactor'] ?? 1, updateAverageCapabilityFactory('measure_voltage'), sumAverageUpdateInterval, device), {
                minInterval: minMeasurementInterval,
                maxInterval: maxMeasurementInterval,
                minChange: minVoltageMeasurementChange,
            })
                .then(() => device.log('Initialised measure_voltage.phase_b capability'))
                .catch(e => device.error('Failed to initialise measure_voltage.phase_b capability', e));
        }
        if (device.hasCapability('measure_current.phase_b')) {
            device.log('Initialising measure_current.phase_b capability');
            await (0, attributeDevice_1.initReadOnlyCapability)(device, zclNode, 'measure_current.phase_b', ExtendedElectricalMeasurementCluster_1.ExtendedElectricalMeasurementCluster, 'rmsCurrentPhB', (0, deviceFactor_1.factorReportParserBuilder)(() => device['acCurrentFactor'] ?? 1, updateSummationCapabilityFactory('measure_current'), sumAverageUpdateInterval, device), {
                minInterval: minMeasurementInterval,
                maxInterval: maxMeasurementInterval,
                minChange: minCurrentMeasurementChange,
            })
                .then(() => device.log('Initialised measure_current.phase_b capability'))
                .catch(e => device.error('Failed to initialise measure_current.phase_b capability', e));
        }
        if (device.hasCapability('measure_power.phase_b')) {
            device.log('Initialising measure_power.phase_b capability');
            await (0, attributeDevice_1.initReadOnlyCapability)(device, zclNode, 'measure_power.phase_b', ExtendedElectricalMeasurementCluster_1.ExtendedElectricalMeasurementCluster, 'activePowerPhB', (0, deviceFactor_1.factorReportParserBuilder)(() => device['activePowerFactor'] ?? 1, updateSummationCapabilityFactory('measure_power'), sumAverageUpdateInterval, device), {
                minInterval: minMeasurementInterval,
                maxInterval: maxMeasurementInterval,
                minChange: minPowerMeasurementChange,
            })
                .then(() => device.log('Initialised measure_power.phase_b capability'))
                .catch(e => device.error('Failed to initialise measure_power.phase_b capability', e));
        }
    }
    if (measurementFlags && measurementFlags.includes('phaseCMeasurement')) {
        device.log('Initialising Phase C measurements');
        if (device.hasCapability('measure_voltage.phase_c')) {
            device.log('Initialising measure_voltage.phase_c capability');
            await (0, attributeDevice_1.initReadOnlyCapability)(device, zclNode, 'measure_voltage.phase_c', ExtendedElectricalMeasurementCluster_1.ExtendedElectricalMeasurementCluster, 'rmsVoltagePhC', (0, deviceFactor_1.factorReportParserBuilder)(() => device['acVoltageFactor'] ?? 1, updateAverageCapabilityFactory('measure_voltage'), sumAverageUpdateInterval, device), {
                minInterval: minMeasurementInterval,
                maxInterval: maxMeasurementInterval,
                minChange: minVoltageMeasurementChange,
            })
                .then(() => device.log('Initialised measure_voltage.phase_c capability'))
                .catch(e => device.error('Failed to initialise measure_voltage.phase_c capability', e));
        }
        if (device.hasCapability('measure_current.phase_c')) {
            device.log('Initialising measure_current.phase_b capability');
            await (0, attributeDevice_1.initReadOnlyCapability)(device, zclNode, 'measure_current.phase_c', ExtendedElectricalMeasurementCluster_1.ExtendedElectricalMeasurementCluster, 'rmsCurrentPhC', (0, deviceFactor_1.factorReportParserBuilder)(() => device['acCurrentFactor'] ?? 1, updateSummationCapabilityFactory('measure_current'), sumAverageUpdateInterval, device), {
                minInterval: minMeasurementInterval,
                maxInterval: maxMeasurementInterval,
                minChange: minCurrentMeasurementChange,
            })
                .then(() => device.log('Initialised measure_current.phase_c capability'))
                .catch(e => device.error('Failed to initialise measure_current.phase_c capability', e));
        }
        if (device.hasCapability('measure_power.phase_c')) {
            device.log('Initialising measure_power.phase_c capability');
            await (0, attributeDevice_1.initReadOnlyCapability)(device, zclNode, 'measure_power.phase_c', ExtendedElectricalMeasurementCluster_1.ExtendedElectricalMeasurementCluster, 'activePowerPhC', (0, deviceFactor_1.factorReportParserBuilder)(() => device['activePowerFactor'] ?? 1, updateSummationCapabilityFactory('measure_power'), sumAverageUpdateInterval, device), {
                minInterval: minMeasurementInterval,
                maxInterval: maxMeasurementInterval,
                minChange: minPowerMeasurementChange,
            })
                .then(() => device.log('Initialised measure_power.phase_c capability'))
                .catch(e => device.error('Failed to initialise measure_power.phase_c capability', e));
        }
    }
    device.log('Electrical measurement device initialized!');
}
exports.default = initElectricalMeasurementDevice;
