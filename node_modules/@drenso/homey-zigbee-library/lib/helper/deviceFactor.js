"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.factorReportParserBuilder = void 0;
const factorProperties = {
    acVoltageFactor: {
        value: 'rmsVoltage', multiplier: 'acVoltageMultiplier', divisor: 'acVoltageDivisor',
    },
    acCurrentFactor: {
        value: 'rmsCurrent', multiplier: 'acCurrentMultiplier', divisor: 'acCurrentDivisor',
    },
    activePowerFactor: {
        value: 'activePower', multiplier: 'acPowerMultiplier', divisor: 'acPowerDivisor',
    },
    instantaneousDemandFactor: {
        value: 'instantaneousDemand', multiplier: 'multiplier', divisor: 'divisor',
    },
    meteringFactor: {
        value: 'currentSummationDelivered', multiplier: 'multiplier', divisor: 'divisor',
    },
};
function factorReportParserBuilder(factor, onReport, onReportTimeout, device) {
    return function (value) {
        if (value < 0) {
            return null;
        }
        const factorValue = value * factor();
        if (onReport) {
            if (device) {
                device.homey.setTimeout(onReport, (onReportTimeout ?? 1) * 1000);
            }
            else {
                onReport();
            }
        }
        return factorValue;
    };
}
exports.factorReportParserBuilder = factorReportParserBuilder;
async function initFactorImplementation(device, zclNode, capability, clusterSpec, storeProperty, endPointId, noPowerFactorReporting, { minMeasurementInterval = 10, maxMeasurementInterval = 3600, minMeasurementChange = 1, } = {}, onReport, onReportTimeout = 1, additionalMultiplier) {
    // Restore factor from store
    await updateDeviceFactor(device, storeProperty, undefined, undefined, additionalMultiplier)
        .catch(e => device.error(`Failed to restore ${storeProperty}`, e));
    const endpoint = endPointId ?? device.getClusterEndpoint(clusterSpec) ?? 1;
    const cluster = zclNode
        .endpoints[endpoint]
        .clusters[clusterSpec.NAME];
    const reportParser = factorReportParserBuilder(() => device[storeProperty] ?? 1, onReport, onReportTimeout, device);
    const properties = factorProperties[storeProperty];
    // Retrieve initial values
    await cluster
        .readAttributes([properties.value, properties.multiplier, properties.divisor])
        .then(async (result) => {
        await updateDeviceFactor(device, storeProperty, result[properties.multiplier], result[properties.divisor]);
        await device
            .setCapabilityValue(capability, reportParser(result[properties.value]))
            .catch(e => device.error(`Failed to set ${capability} capability value`, e));
    })
        .catch(e => device.error(`Failed to read ${clusterSpec.NAME} ${Object.values(properties)} attributes`, e));
    // Configure reporting for the power factor
    if (noPowerFactorReporting !== true) {
        await device
            .configureAttributeReporting([
            {
                endpointId: endpoint,
                cluster: clusterSpec,
                attributeName: properties.multiplier,
                minInterval: 0,
                maxInterval: 3600,
                minChange: 1,
            }, {
                endpointId: endpoint,
                cluster: clusterSpec,
                attributeName: properties.divisor,
                minInterval: 0,
                maxInterval: 3600,
                minChange: 1,
            },
        ])
            .catch(e => device.error(`Failed to configure ${clusterSpec.NAME} [${properties.multiplier}, ${properties.divisor}] attribute reporting`, e));
    }
    // Register listener for incoming report
    cluster.on('attr.' + properties.multiplier, (value) => {
        console.log(properties.multiplier + ' attribute report received', value);
        updateDeviceFactor(device, storeProperty, value);
    });
    cluster.on('attr.' + properties.divisor, (value) => {
        console.log(properties.divisor + ' attribute report received', value);
        updateDeviceFactor(device, storeProperty, undefined, value);
    });
    // Configure the capability
    device.registerCapability(capability, clusterSpec, {
        get: properties.value,
        report: properties.value,
        getOpts: {
            getOnStart: false,
        },
        reportOpts: {
            configureAttributeReporting: {
                minInterval: minMeasurementInterval,
                maxInterval: maxMeasurementInterval,
                minChange: minMeasurementChange,
            },
        },
        reportParser,
    });
}
exports.default = initFactorImplementation;
async function updateDeviceFactor(device, storeProperty, multiplier, divisor, additionalMultiplier) {
    device.log(`Handling new ${storeProperty}`, multiplier, divisor);
    const multiplierKey = storeProperty + '_multiplier';
    const divisorKey = storeProperty + '_divisor';
    const additionalMultiplierKey = storeProperty + '_additional_multiplier';
    if (multiplier) {
        await device.setStoreValue(multiplierKey, multiplier)
            .catch(e => device.error(`Failed to store ${multiplierKey}`, e));
    }
    else {
        multiplier = device.getStoreValue(multiplierKey);
    }
    if (divisor) {
        await device.setStoreValue(divisorKey, divisor)
            .catch(e => device.error(`Failed to store ${divisorKey}`, e));
    }
    else {
        divisor = device.getStoreValue(divisorKey);
    }
    if (additionalMultiplier) {
        await device.setStoreValue(additionalMultiplierKey, additionalMultiplier)
            .catch(e => device.error(`Failed to store ${additionalMultiplierKey}`, e));
    }
    else {
        additionalMultiplier = device.getStoreValue(additionalMultiplierKey);
    }
    device[storeProperty] = ((multiplier ?? 1) / (divisor ?? 1)) * (additionalMultiplier ?? 1);
    device.log(`New active ${storeProperty}`, device[storeProperty]);
}
